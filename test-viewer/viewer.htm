<html>
<head>
<!--<script src="gl-matrix-min.js"></script>-->
<script src="three.min.js"></script>
<script src="GfxState.js"></script>
<script src="GfxCommand.js"></script>
<script src="GfxOps.js"></script>
<script src="RGBA32.js"></script>
</head>
<body style="background: #111; color: #FFF;">

<div style="text-align: center;">
<div style="display: inline-block; margin: auto auto; text-align: left;">
    <div style="padding-bottom: 10px;"><input type="file" id="file"></div>
    <div id="container"></div>
    <div id="log" style="background-color:#000; height: 250px; overflow-y: auto; font-family: consolas; font-size: 12px; padding: 5px;"></div>
    <pre id="ginf"></pre>
</div>
</div>
<script>

function Viewer(containerDomSelector)
{
    this.gfx = new GfxState();
    this.keysDown = {};

    this.camSpeedZ = 0;
    this.camSpeedX = 0;
    this.camSpeedY = 0;

    this.camRotSpeedX = 0;
    this.camRotSpeedY = 0;

    this.width = 720;
    this.height = 480;

    this.scene = new THREE.Scene();

    this.scene.fog = new THREE.Fog(0xC8C896, 1, 5000);
    //this.scene.fog.color = 0xFFFFFFFF;

    this.renderer = new THREE.WebGLRenderer({antialias: false});
    this.renderer.setPixelRatio(window.devicePixelRatio);
    this.renderer.setSize(this.width, this.height);
    
    this.renderer.setScissorTest(true);
    this.renderer.alpha = true;
    this.renderer.setClearColor(0xC8C896, 1.0);
    this.renderer.setViewport(0, 0, this.width, this.height);
    this.renderer.setScissor(0, 0, this.width, this.height);
    this.renderer.domElement.tabIndex = '0'
    this.renderer.domElement.viewer = this;

    this.renderer.domElement.onkeydown = function(e)
    {
        this.viewer.keysDown[e.keyCode] = true;
    	e.preventDefault();
    	return false;
    }

    this.renderer.domElement.onkeyup = function(e)
    {
    	delete this.viewer.keysDown[e.keyCode];
    	e.preventDefault();
    	return false;
    }

    this.renderer.domElement.oncontextmenu = function(e)
    {
        e.preventDefault();
        return false;
    }

    this.renderer.domElement.onmousedown = function(e)
    {
        this.requestPointerLock();
        this.focus();
        e.preventDefault();
        return false;
    }

    var lastMovementX = 0;
    var lastMovementY = 0;

    this.renderer.domElement.onmousemove = function(e)
    {
        if(e.buttons == 0)
        {
            return;
        }

        var movementX = (lastMovementX*4 + e.movementX) / 5;
        var movementY = (lastMovementY*4 + e.movementY) / 5;
        lastMovementX = movementX;
        lastMovementY = movementY;

        if(e.buttons == 1)
        {
            viewer.camera.translateX(-movementX * 5);
            viewer.camera.translateY(movementY * 5);
        }

        if(e.buttons == 4)
        {
            viewer.camera.translateZ(-movementX * 5);
            viewer.camera.translateZ(movementY * 5);
        }

        if(e.buttons == 2)
        {
            //viewer.camRotSpeedX = -e.movementX * 20;
            viewer.camera.rotateY(-movementX * 0.01);
            viewer.camera.rotateX(-movementY * 0.01);
            viewer.camera.rotation.z = 0;
        }
    }

    this.renderer.domElement.onmouseup = function(e)
    {
        lastMovementX = 0;
        lastMovementY = 0;
        document.exitPointerLock();
    }

    this.keyEvents = {
	    //27: function(){ _this.resetCamera() }, // esc - reset camera position
	    87: function(viewer){ viewer.camSpeedZ = -10; }, // w - move forward
	    65: function(viewer){ viewer.camSpeedX = -10; }, // a - pan left
	    83: function(viewer){ viewer.camSpeedZ = 10; }, // s - move backward
	    68: function(viewer){ viewer.camSpeedX = 10; }, // d - pan right
	    90: function(viewer){ viewer.camSpeedY = -10; }, // z - move down
	    88: function(viewer){ viewer.camSpeedY = 10; }, // x - move up
	    40: function(viewer){ viewer.camRotSpeedX = -20; }, // down - rotate down
	    38: function(viewer){ viewer.camRotSpeedX =  20; }, // up - rotate up
	    37: function(viewer){ viewer.camRotSpeedY =  20;;}, // left - rotate left
	    39: function(viewer){ viewer.camRotSpeedY = -20;}  // right - rotate right
    }

    document.querySelector(containerDomSelector).appendChild(this.renderer.domElement);

    this.camera = new THREE.PerspectiveCamera(60, this.width/this.height, 1, 10000);
    this.camera.rotation.order = "YXZ";
}

Viewer.prototype.animate = function()
{
    viewer.camera.translateZ(this.camSpeedZ);
    viewer.camera.translateX(this.camSpeedX);
    viewer.camera.translateY(this.camSpeedY);

    viewer.camera.rotateX(this.camRotSpeedX / 1000);
    viewer.camera.rotateY(this.camRotSpeedY / 1000);
    viewer.camera.rotation.z = 0;

    if(this.camSpeedZ < 0) this.camSpeedZ += 0.25;
    if(this.camSpeedZ > 0) this.camSpeedZ -= 0.25;
    if(this.camSpeedX > 0) this.camSpeedX -= 0.25;
    if(this.camSpeedX < 0) this.camSpeedX += 0.25;
    if(this.camSpeedY > 0) this.camSpeedY -= 0.25;
    if(this.camSpeedY < 0) this.camSpeedY += 0.25;
    if(this.camRotSpeedX > 0) this.camRotSpeedX -= 1;
    if(this.camRotSpeedX < 0) this.camRotSpeedX += 1;
    if(this.camRotSpeedY > 0) this.camRotSpeedY -= 1;
    if(this.camRotSpeedY < 0) this.camRotSpeedY += 1;

    for(var k in this.keysDown)
    {
        if(k in this.keyEvents) this.keyEvents[k](this);
    }

    this.renderer.render(this.scene, this.camera)
    requestAnimationFrame(this.animate.bind(this));
}

Viewer.prototype.setSize = function(width, height)
{
    this.renderer.setSize(width, height);
}

Viewer.prototype.loadDumpFile = function(ab)
{
    var dv = new DataView(ab);

    var metaOffset = dv.byteLength - 0x14;
    var meta = {
        signature:              dv.getUint32(metaOffset + 0x00, false),
        microcodeAddress:       dv.getUint32(metaOffset + 0x04, true),
        microcodeChecksum:      dv.getUint32(metaOffset + 0x08, true),
        rootDisplayListAddress: dv.getUint32(metaOffset + 0x0C, true),
        rootDisplayListSize:    dv.getUint32(metaOffset + 0x10, true)
    };

    document.querySelector('#ginf').innerHTML = (
        "ucode address:  " + hex(meta.microcodeAddress) + "\n" +
        "ucode checksum: " + hex(meta.microcodeChecksum) + "\n" +
        "dlist address:  " + hex(meta.rootDisplayListAddress) + "\n"
    );

    // build intermediate mesh
    this.gfx.importOps(GfxOps.RDP, GfxOps.F3DEX2);
    this.gfx.setMainMemory(dv);
    this.gfx.run(meta.rootDisplayListAddress);

    // build threejs scene
    this.buildScene();

    document.querySelector('#log').innerHTML = this.gfx.loghtm;
}


Viewer.prototype.buildScene = function()
{
    while(this.scene.children.length > 0)
    {
        this.scene.remove(this.scene.children[0]); 
    }

    var dataTextures = [];

    for(var i = 0; i < this.gfx.images.length; i++)
    {
        var rawImage = this.gfx.images[i]; 
        if(rawImage.data == null)
        {
            dataTextures.push(null);
        }
        else
        {
            var dataTexture = new THREE.DataTexture(rawImage.data, rawImage.width, rawImage.height, THREE.RGBAFormat);
            dataTextures.push(dataTexture);
        }
    }

    
    var wireframeMaterial = new THREE.MeshBasicMaterial({ color: 0x000000, opacity: 0.5, transparent: true, wireframe: true });
    var testMaterial = new THREE.MeshBasicMaterial({ opacity: 0.9, transparent: true, polygonOffset: true, polygonOffsetFactor: 1, polygonOffsetUnits: 1, vertexColors: THREE.VertexColors});

    var fillMaterial = new THREE.MeshBasicMaterial({
        transparent: true,
        side: THREE.DoubleSide});

    // build a threejs geometry for each polylist and add to scene

    //var polyOffset = 0;

    for(var i = 0; i < this.gfx.polylists.length; i++)
    {
        var polylist = this.gfx.polylists[i];
        var triangles = polylist.triangles;
        var gfxMaterial = this.gfx.materials[polylist.materialIndex];
        var imageIndex = gfxMaterial.imageIndex;
        var dataTexture = dataTextures[imageIndex];
        
        var geometry = new THREE.Geometry();

        var faceIdx = 0;

        geometry.faceVertexUvs[0] = [];

        for(var j = 0; j < triangles.length; j++)
        {
            var tri = triangles[j];
            geometry.vertices.push(tri[0].position);
            geometry.vertices.push(tri[1].position);
            geometry.vertices.push(tri[2].position);

            if(dataTexture != null)
            {
                var u0 = (tri[0].texcoords.x / dataTexture.image.width) * gfxMaterial.scaleS;
                var v0 = (tri[0].texcoords.y / dataTexture.image.height) * gfxMaterial.scaleT;
                var u1 = (tri[1].texcoords.x / dataTexture.image.width) * gfxMaterial.scaleS;
                var v1 = (tri[1].texcoords.y / dataTexture.image.height) * gfxMaterial.scaleT;
                var u2 = (tri[2].texcoords.x / dataTexture.image.width) * gfxMaterial.scaleS;
                var v2 = (tri[2].texcoords.y / dataTexture.image.height) * gfxMaterial.scaleT;

                geometry.faceVertexUvs[0].push([
                    new THREE.Vector2(u0, v0),
                    new THREE.Vector2(u1, v1),
                    new THREE.Vector2(u2, v2),
                ]);
            }

            var face = new THREE.Face3(faceIdx + 0, faceIdx + 1, faceIdx + 2);
            face.vertexColors[0] = tri[0].color;
            face.vertexColors[1] = tri[1].color;
            face.vertexColors[2] = tri[2].color;

            geometry.faces.push(face);
            faceIdx += 3;
        }

        //var fillMaterial;
        if(dataTexture != null)
        {
            switch(gfxMaterial.cmS)
            {
            case 0: dataTexture.wrapS = THREE.RepeatWrapping; break;
            case 1: dataTexture.wrapS = THREE.MirroredRepeatWrapping; break;
            case 2: dataTexture.wrapS = THREE.ClampToEdgeWrapping; break;
            case 3: dataTexture.wrapS = THREE.MirroredRepeatWrapping; break;
            }

            switch(gfxMaterial.cmT)
            {
            case 0: dataTexture.wrapT = THREE.RepeatWrapping; break;
            case 1: dataTexture.wrapT = THREE.MirroredRepeatWrapping; break;
            case 2: dataTexture.wrapT = THREE.ClampToEdgeWrapping; break;
            case 3: dataTexture.wrapT = THREE.MirroredRepeatWrapping; break;
            }

            // todo othermodeh TEXTFILT
            dataTexture.minFilter = THREE.LinearFilter;
            dataTexture.magFilter = THREE.LinearFilter;

            dataTexture.needsUpdate = true;

            fillMaterial = new THREE.MeshBasicMaterial({
                map: dataTexture,
                transparent: true,
                side: THREE.DoubleSide
            });

            // kokiri decal test
            if(this.gfx.images[gfxMaterial.imageIndex].address == 0x2fd190 ||
               this.gfx.images[gfxMaterial.imageIndex].address == 0x383558)
            {
                fillMaterial.polygonOffset = true;
                fillMaterial.polygonOffsetFactor = 1;
                fillMaterial.polygonOffsetUnits = 1;
            }
            // todo geometrymode cull (THREE.FrontSide, THREE.BackSide, THREE.DoubleSide)
            // todo polygon offset for when rendermode decal is set
        }
        else
        {
            fillMaterial = testMaterial;
        }

        var fillMesh = new THREE.Mesh(geometry, fillMaterial)
        //var wireframeMesh = new THREE.Mesh(geometry, wireframeMaterial)

        this.scene.add(fillMesh);
        //this.scene.add(wireframeMesh);
        //console.log(this.gfx.polylists[i]);
    }
}

function hex(n)
{
    var s = n.toString(16).toUpperCase();
    while(s.length < 8) s = "0" + s;
    return s;
}

function attachFileReader(query, onloadend)
{
    var domFileInput = document.querySelector(query);
    var reader = new FileReader();
    reader.onloadend = function()
    {
        setTimeout(function(){onloadend(reader.result)}, 1);
        //onloadend(reader.result);
    }

    domFileInput.addEventListener('change', function()
    {
        reader.readAsArrayBuffer(domFileInput.files[0]);
    });
}

attachFileReader('#file', function(ab)
{
    viewer.loadDumpFile(ab);
})

var viewer = new Viewer('#container');

viewer.animate();


</script>
</body>