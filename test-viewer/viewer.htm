<html>
<head>
<!--<script src="gl-matrix-min.js"></script>-->
<script src="three.min.js"></script>
<script src="GfxState.js"></script>
<script src="GfxCommand.js"></script>
<script src="GfxOps.js"></script>
</head>
<body>
<input type="file" id="file"><br><br>
<div id="container"></div>

<pre id="ginf"></pre>
<script>

function Viewer(containerDomSelector)
{
    this.gfx = new GfxState();
    this.keysDown = {};

    this.scene = new THREE.Scene();

    this.renderer = new THREE.WebGLRenderer({antialias: false});
    this.renderer.setPixelRatio(window.devicePixelRatio);
    
    this.renderer.setScissorTest(true);
    this.renderer.alpha = true;
    this.renderer.setClearColor(0x222222, 1.0);
    this.renderer.setViewport(0, 0, 800, 600);
    this.renderer.setScissor(0, 0, 800, 600);
    this.renderer.domElement.tabIndex = '0'
    this.renderer.domElement.viewer = this;

    this.renderer.domElement.onkeydown = function(e)
    {
        this.viewer.keysDown[e.keyCode] = true;
    	e.preventDefault();
    	return false;
    }

    this.renderer.domElement.onkeyup = function(e)
    {
    	delete this.viewer.keysDown[e.keyCode];
    	e.preventDefault();
    	return false;
    }

    this.keyEvents = {
	    //27: function(){ _this.resetCamera() }, // esc - reset camera position
	    87: function(viewer){ viewer.camera.translateZ(-10); }, // w - move forward
	    65: function(viewer){ viewer.camera.translateX(-10); }, // a - pan left
	    83: function(viewer){ viewer.camera.translateZ( 10); }, // s - move backward
	    68: function(viewer){ viewer.camera.translateX( 10); }, // d - pan right
	    90: function(viewer){ viewer.camera.translateY(-10); }, // z - move down
	    88: function(viewer){ viewer.camera.translateY( 10); }, // x - move up
	    40: function(viewer){ viewer.camera.rotateX( -0.05); }, // down - rotate down
	    38: function(viewer){ viewer.camera.rotateX(  0.05); }, // up - rotate up
	    37: function(viewer){ viewer.camera.rotateY(  0.05); viewer.camera.rotation.z = 0;}, // left - rotate left
	    39: function(viewer){ viewer.camera.rotateY( -0.05); viewer.camera.rotation.z = 0;}  // right - rotate right
    }

    document.querySelector(containerDomSelector).appendChild(this.renderer.domElement);

    this.camera = new THREE.PerspectiveCamera(60, 800/600, 1, 15000);
    this.camera.rotation.order = "YXZ";
}

Viewer.prototype.animate = function()
{
    for(var k in this.keysDown)
    {
        if(k in this.keyEvents) this.keyEvents[k](this);
    }

    this.renderer.render(this.scene, this.camera)
    requestAnimationFrame(this.animate.bind(this));
}

Viewer.prototype.setSize = function(width, height)
{
    this.renderer.setSize(width, height);
}

Viewer.prototype.loadDumpFile = function(ab)
{
    var dv = new DataView(ab);

    var metaOffset = dv.byteLength - 0x14;
    var meta = {
        signature:              dv.getUint32(metaOffset + 0x00, false),
        microcodeAddress:       dv.getUint32(metaOffset + 0x04, true),
        microcodeChecksum:      dv.getUint32(metaOffset + 0x08, true),
        rootDisplayListAddress: dv.getUint32(metaOffset + 0x0C, true),
        rootDisplayListSize:    dv.getUint32(metaOffset + 0x10, true)
    };

    document.querySelector('#ginf').innerHTML = (
        "ucode address:  " + hex(meta.microcodeAddress) + "\n" +
        "ucode checksum: " + hex(meta.microcodeChecksum) + "\n" +
        "dlist address:  " + hex(meta.rootDisplayListAddress) + "\n"
    );

    // build intermediate mesh
    this.gfx.importOps(GfxOps.RDP, GfxOps.F3DEX2);
    this.gfx.setMainMemory(dv);
    this.gfx.run(meta.rootDisplayListAddress);

    // build threejs scene
    this.buildScene();
}


Viewer.prototype.buildScene = function()
{
    while(this.scene.children.length > 0)
    {
        this.scene.remove(this.scene.children[0]); 
    }

    var dataTextures = [];

    for(var i = 0; i < this.gfx.images.length; i++)
    {
        var rawImage = this.gfx.images[i]; 
        if(rawImage.data == null)
        {
            dataTextures.push(null);
        }
        else
        {
            var dataTexture = new THREE.DataTexture(rawImage.data, rawImage.width, rawImage.height, THREE.RGBAFormat);
            dataTextures.push(dataTexture);
        }
    }

    
    var wireframeMaterial = new THREE.MeshBasicMaterial({ color: 0x000000, opacity: 0.5, transparent: true, wireframe: true });
    var testMaterial = new THREE.MeshBasicMaterial({ opacity: 0.9, transparent: true, polygonOffset: true, polygonOffsetFactor: 1, polygonOffsetUnits: 1, vertexColors: THREE.VertexColors});
    //var testMaterial = new THREE.MeshBasicMaterial({ opacity: 0.9, transparent: true, polygonOffset: true, polygonOffsetFactor: 1, polygonOffsetUnits: 1, color: 0xFF00FFFF});
    
    //var dataTexture = new THREE.DataTexture(
    //    this.gfx.images[4].data,
    //    this.gfx.images[4].width,
    //    this.gfx.images[4].height,
    //    THREE.RGBAFormat);
    //var imageMaterial = new THREE.MeshBasicMaterial({map: dataTexture})

    //console.log(this.gfx.testTexture)

    // build a threejs geometry for each polylist and add to scene

    for(var i = 0; i < this.gfx.polylists.length; i++)
    {
        var polylist = this.gfx.polylists[i];
        var triangles = polylist.triangles;
        var gfxMaterial = this.gfx.materials[polylist.materialIndex];
        var imageIndex = gfxMaterial.imageIndex;
        var dataTexture = dataTextures[imageIndex];
        
        var geometry = new THREE.Geometry();

        var faceIdx = 0;

        geometry.faceVertexUvs[0] = [];

        for(var j = 0; j < triangles.length; j++)
        {
            var tri = triangles[j];
            geometry.vertices.push(tri[0].position);
            geometry.vertices.push(tri[1].position);
            geometry.vertices.push(tri[2].position);

            //console.log(dataTexture);

            if(dataTexture)
            {
                var u0 = (tri[0].texcoords.x / dataTexture.image.width);
                var v0 = (tri[0].texcoords.y / dataTexture.image.height);
                var u1 = (tri[1].texcoords.x / dataTexture.image.width);
                var v1 = (tri[1].texcoords.y / dataTexture.image.height);
                var u2 = (tri[2].texcoords.x / dataTexture.image.width);
                var v2 = (tri[2].texcoords.y / dataTexture.image.height);

                //console.log(u0, v0);

                geometry.faceVertexUvs[0].push([
                    new THREE.Vector2(u0, v0),
                    new THREE.Vector2(u1, v1),
                    new THREE.Vector2(u2, v2),
                ]);
            }

            var face = new THREE.Face3(faceIdx + 0, faceIdx + 1, faceIdx + 2);
            face.vertexColors[0] = tri[0].color;
            face.vertexColors[1] = tri[1].color;
            face.vertexColors[2] = tri[2].color;

            geometry.faces.push(face);
            faceIdx += 3;
        }

        var fillMaterial;
        if(dataTexture != null)
        {
            /*
            ClampToEdgeWrapping
            RepeatWrapping
            MirroredRepeatWrapping
            */
            dataTexture.wrapS = THREE.RepeatWrapping;
            dataTexture.wrapT = THREE.RepeatWrapping;
            dataTexture.magFilter = THREE.LinearFilter;
            dataTexture.minFilter = THREE.LinearFilter;
            fillMaterial = new THREE.MeshBasicMaterial({map: dataTexture});
        }
        else
        {
            fillMaterial = testMaterial;
        }

        var fillMesh = new THREE.Mesh(geometry, fillMaterial)
        //var wireframeMesh = new THREE.Mesh(geometry, wireframeMaterial)

        this.scene.add(fillMesh);
        //this.scene.add(wireframeMesh);
        //console.log(this.gfx.polylists[i]);
    }
}

function hex(n)
{
    var s = n.toString(16).toUpperCase();
    while(s.length < 8) s = "0" + s;
    return s;
}

function attachFileReader(query, onloadend)
{
    var domFileInput = document.querySelector(query);
    var reader = new FileReader();
    reader.onloadend = function()
    {
        onloadend(reader.result);
    }

    domFileInput.addEventListener('change', function()
    {
        reader.readAsArrayBuffer(domFileInput.files[0]);
    });
}

attachFileReader('#file', function(ab)
{
    viewer.loadDumpFile(ab);
})

var viewer = new Viewer('#container');
viewer.setSize(800, 600);
viewer.animate();


</script>
</body>